# Doris periodic backup job

kind: CronJob
apiVersion: batch/v1
metadata:
  name: basic-doris-backup-scheduler
  labels:
    app.kubernetes.io/name: doris-cluster
    app.kubernetes.io/instance: basic
    app.kubernetes.io/component: backup-scheduler
    app.kubernetes.io/managed-by: doris-operator

spec:
  schedule: "*/2 * * * *"
  startingDeadlineSeconds: 600
  concurrencyPolicy: Forbid

  jobTemplate:
    spec:
      parallelism: 1
      backoffLimit: 6
      template:
        metadata:
          labels:
            app.kubernetes.io/name: doris-cluster
            app.kubernetes.io/instance: basic
            app.kubernetes.io/component: initializer
            app.kubernetes.io/managed-by: doris-operator
            doris.apache.org/initializer: initialize-basic
        spec:
          restartPolicy: OnFailure
          volumes:
            - name: check-conn-script
              configMap:
                name: basic-doris-backup-scheduler
                defaultMode: 420
                items:
                  - key: check-conn-script
                    path: check_conn.sh
            - name: backup-script
              configMap:
                name: basic-doris-backup-scheduler
                defaultMode: 420
                items:
                  - key: backup-script
                    path: backup.py
          # init container: checking fe query connection.
          initContainers:
            - name: wait
              image: 'tnir/mysqlclient'
              command: [ 'sh', '/usr/local/bin/check_conn.sh' ]
              volumeMounts:
                - name: check-conn-script
                  mountPath: /usr/local/bin/check_conn.sh
                  subPath: check_conn.sh
                  readOnly: true
              env:
                - name: FE_SVC
                  value: basic-fe
                - name: FE_QUERY_PORT
                  value: '9030'

          # main container: execute backup script
          containers:
            - name: mysql-client
              image: 'tnir/mysqlclient'
              command: [ 'python', '/usr/local/bin/backup.py' ]
              volumeMounts:
                - name: backup-script
                  mountPath: /usr/local/bin/backup.py
                  subPath: backup.py
                  readOnly: true
              env:
                - name: FE_SVC
                  value: basic-fe
                - name: FE_QUERY_PORT
                  value: '9030'
                - name: ACC_USER
                  valueFrom:
                    secretKeyRef:
                      name: basic-opr-account
                      key: user
                - name: ACC_PWD
                  valueFrom:
                    secretKeyRef:
                      name: basic-opr-account
                      key: password
                - name: DATABASE
                  value: 'example_db'
                - name: REPO_NAME
                  value: 'example_repo'
                - name: CREATE_REPO_SQL
                  valueFrom:
                    configMapKeyRef:
                      key: create-repo-sql
                - name: BACKUP_SQL
                  valueFrom:
                    configMapKeyRef:
                      key: backup-sql

---
kind: ConfigMap
apiVersion: v1
metadata:
  name: basic-doris-backup-scheduler
  labels:
    app.kubernetes.io/name: doris-cluster
    app.kubernetes.io/instance: basic
    app.kubernetes.io/component: backup-scheduler
    app.kubernetes.io/managed-by: doris-operator
data:
  create-repo-sql: |
    CREATE REPOSITORY `example_repo`
    WITH BROKER `hdfs_broker`
    ON LOCATION "hdfs://hadoop-name-node:54310/path/to/repo/"
    PROPERTIES
    (
       "username" = "user",
       "password" = "password"
    );
  backup-sql: |
    BACKUP SNAPSHOT example_db.snapshot_label1
    TO example_repo
    ON (example_tbl)
    PROPERTIES ("type" = "full");

  check-conn-script: |
    trap exit TERM
     host=$FE_SVC
     port=$FE_QUERY_PORT
     while true; do
       nc -zv -w 3 $host $port
       if [ $? -eq 0 ]; then
         break
       else
         echo "info: failed to connect to $host:$port, sleep 1 second then retry"
         sleep 1
       fi
     done
     echo "info: successfully connected to $host:$port, able to initialize Doris now"

  backup-script: |
    import MySQLdb
    import os
    import sys
    import time
    
    host = os.environ.get('FE_SVC')
    port = os.environ.get('FE_QUERY_PORT')
    acc_user = os.environ.get('ACC_USER')
    acc_password = os.environ.get('ACC_PASSWORD')
    
    database = os.environ.get('DATABASE')
    repo_name = os.environ.get('REPO_NAME')
    create_repo_sql = os.environ.get('CREATE_REPO_SQL')
    backup_sql = os.environ.get('BACKUP_SQL')
    
    watch_interval = 3
    
    
    def create_conn():
      retry_count = 0
      for i in range(0, 10):
        try:
          _conn = MySQLdb.connect(host=host, port=port, user=acc_user, passwd=acc_password, connect_timeout=5)
        except MySQLdb.OperationalError as e:
          print(e)
          retry_count += 1
          time.sleep(1)
          continue
        break
      if retry_count == 10:
        print('Failed to connect to FE.')
        sys.exit(1)
      return _conn


    def exist_backup_task(_conn):
      cursor = _conn.cursor().execute("show backup from %s;" % database)
      results = cursor.fetchall()
      if len(results) == 0:
        return False
      else:
        state = results[0][3]
        if state == 'FINISHED' or state == 'CANCELLED':
          return False
        else:
          return True
    
    
    def exist_restore_task(_conn):
      cursor = _conn.cursor().execute("show restore from %s;" % database)
      results = cursor.fetchall()
      if len(results) == 0:
        return False
      state = results[0][4]
      if state == 'FINISHED' or state == 'CANCELLED':
        return False
      else:
        return True
    
    
    def create_repo(_conn):
      try:
        cursor = _conn.cursor().execute(create_repo_sql)
        cursor.execute("show create repository for %s;" % repo_name)
      except MySQLdb.Error as error:
        if "repository not exist" in str(error):
          print("Repository(%s) does not exist, creating it..." % repo_name)
          _conn.cursor().execute(create_repo_sql)
          print("Repository(%s) created successfully." % repo_name)
        else:
          print("Failed to create repository(%s): %s" % (repo_name, error))
          sys.exit(1)
    
    
    def watch_backup_task(_conn):
      while True:
        cursor = _conn.cursor().execute("show backup from %s;" % database)
        results = cursor.fetchall()
        if len(results) == 0:
          continue
        state = results[0][3]
        if state == 'FINISHED':
          print("Backup task finished successfully.")
          break
        elif state == 'CANCELLED':
          print("Backup task failed.")
          error_stack = results[0][11]
          status = results[0][12]
          print("status: \n%s" % status)
          print("error stack: \n%s" % error_stack)
          break
        time.sleep(watch_interval)
    
    
    conn = create_conn()
    
    print("Checking if there is a running backup or restore task under the database($s)" % database)
    if exist_backup_task(conn):
      print('There is already a running backup task under database(%s)!' % database)
      sys.exit(1)
    if exist_restore_task(conn):
      print('There is already a running restore task under database(%s)!' % database)
      sys.exit(1)
    
    print("Creating repository(%s) if necessary." % repo_name)
    create_repo(conn)
    
    print("Executing backup sql.")
    conn.cursor.execute(backup_sql)
    
    print("Watching backup task state...")
    watch_backup_task(conn)

